/**
 *
 * \section COPYRIGHT
 *
 * Copyright 2013-2014 The srsLTE Developers. See the
 * COPYRIGHT file at the top-level directory of this distribution.
 *
 * \section LICENSE
 *
 * This file is part of the srsLTE library.
 *
 * srsLTE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * srsLTE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * A copy of the GNU Lesser General Public License can be found in
 * the LICENSE file in the top-level directory of this distribution
 * and at http://www.gnu.org/licenses/.
 *
 */

#include "srslte/srslte.h"
#include "queue.h"

#ifndef UEPHY_H
#define UEPHY_H

#define SYNC_MODE_CV       0
#define SYNC_MODE_CALLBACK 1
#define SYNC_MODE          SYNC_MODE_CALLBACK

namespace srslte {

typedef _Complex float cf_t; 

class ue_phy
{
public:
  
  typedef enum {DOWNLINK=0, UPLINK=1} direction_t; 

  typedef enum {
    PDCCH_UL_SEARCH_CRNTI = 0,
    PDCCH_UL_SEARCH_RA_PROC,
    PDCCH_UL_SEARCH_SPS,
    PDCCH_UL_SEARCH_TEMPORAL,
    PDCCH_UL_SEARCH_TPC_PUSCH,
    PDCCH_UL_SEARCH_TPC_PUCCH
  } pdcch_ul_search_t; 

  typedef enum {
    PDCCH_DL_SEARCH_CRNTI = 0,
    PDCCH_DL_SEARCH_SIRNTI,
    PDCCH_DL_SEARCH_PRNTI,
    PDCCH_DL_SEARCH_RARNTI,
    PDCCH_DL_SEARCH_TEMPORAL,    
    PDCCH_DL_SEARCH_SPS
  } pdcch_dl_search_t; 
    
  /* Uplink/Downlink scheduling grant generated by a successfully decoded PDCCH */ 
  class sched_grant {
  public:
    uint16_t get_rnti();
    uint32_t get_rv();
    void     set_rv(uint32_t rv);
    bool     get_ndi();
    uint32_t get_current_tti();
    bool     get_cqi_request();
    int      get_harq_process();    
    bool     is_uplink();
    bool     is_downlink();
    void*    get_grant_ptr();
  protected: 
    union {
      srslte_ra_pusch_t ul_grant;
      srslte_ra_pdsch_t dl_grant;
    }; 
    direction_t         dir; 
    uint16_t            rnti; 
    uint32_t            current_tti; 
  };
 
  /* Uplink scheduling assignment. The MAC instructs the PHY to prepare an UL packet (PUSCH or PUCCH) 
   * for transmission. The MAC must call generate_pusch() to set the packet ready for transmission
   */
  class ul_buffer : public queue::element {
  public: 
    bool     init_cell(srslte_cell_t cell, int64_t *params_db);
    void     free_cell();
    void     set_tti(uint32_t tti);
    void     set_current_tx_nb(uint32_t current_tx_nb);
    bool     generate_pusch(sched_grant pusch_grant, uint8_t *payload, srslte_uci_data_t uci_data);    
    bool     generate_pucch(srslte_uci_data_t uci_data);
  private: 
    int64_t       *params_db; 
    srslte_cell_t  cell; 
    srslte_ue_ul_t ue_ul; 
    bool           signal_generated; 
    cf_t*          signal_buffer;
    uint32_t       tti; 
    uint32_t       current_tx_nb; 
  };

  /* Class for the processing of Downlink buffers. The MAC obtains a buffer for a given TTI and then 
   * gets ul/dl scheduling grants and/or processes phich/pdsch channels 
   */
  class dl_buffer : public queue::element {
  public:
    bool           init_cell(srslte_cell_t cell, int64_t *params_db);
    void           free_cell();
    bool           get_ul_grant(pdcch_ul_search_t mode, uint32_t rnti, ue_phy::sched_grant *grant);
    bool           get_dl_grant(pdcch_dl_search_t mode, uint32_t rnti, ue_phy::sched_grant *grant);
    bool           decode_phich(srslte_phich_alloc_t assignment);
    bool           decode_pdsch(sched_grant pdsch_grant, uint8_t *payload); // returns true or false for CRC OK/KO
  private: 
    int64_t       *params_db;
    srslte_cell_t  cell; 
    srslte_ue_dl_t ue_dl; 
    srslte_phich_t phich; 
    cf_t          *signal_buffer; 
    uint32_t       cfi; 
    bool           sf_symbols_and_ce_done; 
    bool           pdcch_llr_extracted;    
    uint32_t       tti; 
  };
  
#if SYNC_MODE==SYNC_MODE_CALLBACK
  typedef void (*ue_phy_callback_t) (void); 
  ue_phy_callback_t tti_clock_callback; 
  ue_phy_callback_t status_change;
  ue_phy(ue_phy_callback_t tti_clock_callback, ue_phy_callback_t status_change);
#else
  ue_phy();
#endif
  ~ue_phy();
  
  void measure(); // TBD  
  void dl_bch();  
  void start_rxtx();
  void stop_rxtx();
  bool init_prach();
  void send_prach(uint32_t preamble_idx);  
  
  bool status_is_idle();
  bool status_is_rxtx();
  bool status_bch_decoded(uint8_t payload[SRSLTE_BCH_PAYLOAD_LEN]);
  
  typedef enum {
    
    PARAM_DL_FREQ = 0, 
    PARAM_UL_FREQ, 

    PARAM_CELLSEARCH_TIMEOUT_PSS_NFRAMES, 
    PARAM_CELLSEARCH_TIMEOUT_MIB_NFRAMES, 
    PARAM_CELLSEARCH_FORCE_N_ID_2, 
    PARAM_CELLSEARCH_CORRELATION_THRESHOLD, // integer that will be divided by 10 

    PARAM_PUSCH_BETA, 
    
    PARAM_PUSCH_RS_GROUP_HOPPING_EN,
    PARAM_PUSCH_RS_SEQUENCE_HOPPING_EN,
    PARAM_PUSCH_RS_CYCLIC_SHIFT,
    PARAM_PUSCH_RS_GROUP_ASSIGNMENT,
    
    PARAM_PUSCH_HOPPING_N_SB,
    PARAM_PUSCH_HOPPING_INTRA_SF,
    PARAM_PUSCH_HOPPING_OFFSET,

    PARAMS_UCI_I_OFFSET_ACK,
    PARAMS_UCI_I_OFFSET_RI,
    PARAMS_UCI_I_OFFSET_CQI,
    
    PARAMS_PRACH_CONFIG_INDEX,
    PARAMS_PRACH_ROOT_SEQ_IDX,
    PARAMS_PRACH_HIGH_SPEED_FLAG,
    PARAMS_PRACH_ZC_CONFIG,
    PARAMS_PRACH_FREQ_OFFSET,
    
    PARAM_NOF_PARAMS,    
  } param_t;
  
  
  void set_param(param_t param, int64_t value); 

  uint32_t                get_tti();
#if SYNC_MODE==SYNC_MODE_CV
  std::condition_variable tti_cv; 
  std::mutex              tti_mutex; 
#endif
  
  ul_buffer* get_ul_buffer(uint32_t tti);
  dl_buffer* get_dl_buffer(uint32_t tti);

  void main_radio_loop(); 
  
private:
  enum {
    IDLE, MEASURE, RX_BCH, MIB_DECODED, RXTX
  } phy_state; 

  int64_t *params_db;
  
  srslte_cell_t cell; 
  uint8_t  bch_payload[SRSLTE_BCH_PAYLOAD_LEN];
  bool     is_sfn_synched = false; 
  bool     started        = false; 
  uint32_t current_tti; 
  
  bool     prach_initiated     = false;   
  bool     prach_ready_to_send = false;  
  uint32_t prach_len; 
  cf_t    *prach_buffer[64]; 
  srslte_prach_t prach; 

  queue *ul_buffer_queue;
  queue *dl_buffer_queue; 
  
  pthread_t    radio_thread; 
  void        *radio_handler;
  static void* radio_thread_fnc(void *arg);
  void         run_rx_bch_state();
  bool         rx_bch(); 
  void         run_rx_tx_state();
};

}
#endif